#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//选择排序思想:
//每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的第一个位置，第二个位置...直到全部待排序的数据元素排完。

//堆：逻辑结构(想象成)是一颗完全二叉树。物理结构是一个数组。
//数组中的元素，可以看成一个完全二叉树。
//则，数组某个元素的下标，所在的完全二叉树的节点处（作为父节点），
//1、对应的左孩子节点，在数组中的下标：leftchild = parent*2+1
//2、对应的右孩子节点，在数组中的下标：rightchild = parent*2+2
//则，数组某个元素的下标，所在的完全二叉树的节点处（作为孩子节点），
//3、对应的父节点，在数组中的下标：parent = (child-1)/2

//堆是用数组表示的完全二叉树。
//大堆：树中所有的父节点都大于等于孩子结点。根（堆顶数据）是最大的
//大堆：树中所有的父节点都大于等于孩子结点。根（堆顶数据）是最大的
//小堆：树中所有的父节点都小于等于孩子结点。根是最小的
//如：(101,88,46,70,34,39,45,58,66,10)是堆。这句话是否正确？
//            101
//        88       46
//     70    34  39  45  
//   58  66 10
//故是堆，且是大堆。

//选择排序之堆排序
//核心：借助堆来选择最大的数或最小的数。
//第一步：将数组想象成完全二叉树（前n - 1层都是满的，最后一层不满）
//		由于给的数组，逻辑结构并不一定是大堆或小堆，因此需要先将数组转为逻辑结构的堆。
//第二步：利用向下调整算法AdjustDown建堆(大堆或小堆)
//		利用向下调整算法建小堆的前提是，以根结点开始，左右子树都是小堆。
//		向下调整算法：从根结点开始，选出左右结点下标中小的那个数据，与根结点下标比较，如果比根结点下标小，则交换数据。
//	让孩子下标作为根结点，继续选出左右结点下标中小的那个数据，与根结点下标比较，如果比根结点下标小，则交换数据....继续向下调整
//	直到叶子结点下标超过数组下标结束。
//		利用向下调整算法建大堆的前提是，以根结点开始，左右子树都是大堆。
//		向下调整算法：从根结点开始，选出左右结点下标中大的那个数据，与根结点下标比较，如果比根结点下标大，则交换数据。
//	让孩子下标作为根结点，继续选出左右结点下标中大的那个数据，与根结点下标比较，如果比根结点下标大，则交换数据....继续向下调整
//	直到叶子结点下标超过数组下标结束。	
//对于左右子树并不同时为大堆或小堆，就不能直接使用向下调整算法，怎么办？
//如：(3,5,2,7,8,6,1,9,4,0)
//       3
//    5    2
//  7   8 6  1
// 9 4 0 
//倒着从最后一颗子树开始调整，即数组最后一个下标开始，也就是0作为根节点的子树开始调整。
//发现，叶子结点不需要调整，没有左右子结点，本身就是一个大堆或小堆。
//因此，从倒数最后一个非叶子结点开始调整，也就是8作为根节点的子树。
//8的位置如何确定？也就是数组最后一个下标的父节点，即parent = ((n-1)-1)/2
/*
//第三步：建堆
for (int i = ((n - 1) - 1) / 2; i >= 0; --i)
{
	AdjustDown(a, n, i);
}
//注意：当“左右子树并不同时为大堆或小堆”的时候，需要从后往前建堆。当“左右子树同时为大堆或小堆”的时候，AdjustDown就是建堆。
*/
//此时，该(3,5,2,7,8,6,1,9,4,0)数组构成的二叉树，就调整好了堆。
//第四步：排序
//1、排升序是建大堆，还是建小堆？-- 排升序建大堆。排降序建小堆。
//选择排序的堆排序是通过堆来选数的，如果是建小堆，最小的数在堆顶，已经被选出来了。
//那么再在剩下的数中再去选最小的数，就需要在剩下的数中重新建堆，才能选出下一个数，此时第二个数作根，但是剩下的二叉树结构都乱了。
//可能剩下的数不是符合左右子树都是小堆或小堆，又需要重新建小堆或小堆。第一次建堆时间复杂度为F(N) = N - log2 N = O(N)
//那么每次建堆选数，的时间复杂度是F(N) = N + (N-1) + (N-2) + ...  = O(N^2)，那么这样不是不可以，但是堆排序就没有效率优势了。还不如遍历选数。
//2、排升序为什么要建大堆？
//选择排序的堆排序是通过堆来选数的，第一个数是堆最大的数，将第一个数和最后一个数交换，此时，把最后一个数不看作堆里面的。
//前n-1个数向下调整，选出第一个数(最大的数)，再跟倒数第二个位置的数交换，此时，把最后第二个数不看作堆里面的。
//继续向下调整....当只有一个数的时候停止。
//那么每次选数调整的时间复杂度是F(N) = N*log2 N = O(N*log2 N)

void swap02(int* c, int* p)
{
	int tmp = *c;
	*c = *p;
	*p = tmp;
}
//向下调整算法：必须左右子树都是大堆或小堆
//向下调整算法最多调整高度次。即2^h - 1 C x = N 得：高度h = log2 (N+1+x)故时间复杂度O(N) = log2 N。
/*
void AdjustDown(int* a, int n, int root)//此处建小堆
{
	int parent = root;//根结点下标
	int child = parent * 2 + 1;//假设child默认为左孩子下标
	//下标不能超过n
	while (child < n)//n是数组元素个数，也是数组最大下标的下一个值，即child <= n-1
	{
		//1、选出左右孩子中小的那个
		if ((child+1 < n) && (a[child + 1] < a[child]))//左孩子大时。
		{//同时极端情况下，存在没有右孩子，因此右孩子下标满足child + 1 < n,即child + 1在数组最大下标范围内，否则就会越界

			//由于取小的值与父节点比较，即需要更换为右孩子的下标，再与根节点比较。
			child += 1;//左孩子大，则取右孩子的下标。左右孩子下标相差1
		}
		//2、取小的值，与根节点比较。如果比根节点小，则交换，让小的节点的下标做根节点的下标
		if (a[child] < a[parent])
		{
			swap02(&a[child], &a[parent]);
			//更新新的根节点和默认左孩子节点的下标
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			//由于前提条件左右子树必须为小堆，如果来到这里，可判断后面都满足小堆
			break;
		}
	}
}
*/
//注意：建大堆时，将if ((child+1 < n) && (a[child + 1] < a[child]))该为if ((child+1 < n) && (a[child + 1] > a[child]))
//同时，将if (a[child] < a[parent])该为if (a[child] > a[parent])即可。

void AdjustDown(int* a, int n, int root)//此处建大堆
{
	int parent = root;//根结点下标
	int child = parent * 2 + 1;//假设child默认为左孩子下标
	while (child < n)
	{
		//1、选出左右孩子中小的那个
		if ((child + 1 < n) && (a[child + 1] > a[child]))//左孩子大时。
		{
			child += 1;//左孩子大，则取右孩子的下标。左右孩子下标相差1
		}
		//2、取小的值，与根节点比较。如果比根节点小，则交换，让小的节点的下标做根节点的下标
		if (a[child] > a[parent])
		{
			swap02(&a[child], &a[parent]);
			//更新新的根节点和默认左孩子节点的下标
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}
//堆排序时间复杂度：F(N) = 建堆的O(N*log2 N)
void HeapSort(int* a, int n)
{
	//1、建大堆 - 从完全二叉树倒着顺序，使用向下调整算法建堆
	//建堆时间复杂度：F(N) = N - log2 N = O(N)
	for (int i = (n - 1 - 1) / 2; i >= 0; i--)
	{//已知孩子节点，可得父节点
		AdjustDown(a, n, i);
	}

	//2、排升序 - 建大堆为基础
	int end = n - 1;
	while (end > 0)//当只有一个数的时候停止
	{//每次选堆顶最大的数放到数组的最后位置上，再重新调整堆
		swap02(&a[0], &a[end]);
		AdjustDown(a, end, 0);
		--end;
	}
}
#if 0
int main()
{
	int a[] = { 5, 2, 4, 6, 1, 3 };

	int n = sizeof(a) / sizeof(a[0]);

	HeapSort(a, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}
#endif

//多画图。

//堆排序的特性总结：
//1. 堆排序使用堆来选数，效率就高了很多。
//2. 时间复杂度：O(N * logN)
//3. 空间复杂度：O(1)
//4. 稳定性：不稳定