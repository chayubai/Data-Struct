#define _CRT_SECURE_NO_WARNINGS 1

//交换排序思想：
//所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，
//交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。

//交换排序之冒泡排序
//先思考单趟排序，再考虑整体排序。
//每一趟，依次前后元素比较，交换，将最大或最小的数交换到后一个位置，使得数组最后一个下标的元素值最大或最小

#include <stdio.h>

void swap04(int* a, int* b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}

//每次冒泡，将最大的数冒泡到最低端
void BubbleSort01(int* a, int n)//升序排列
{
	for (int i = 0; i < n - 1; i++)//趟数，n个数，只需要冒泡n-1次。(n-2) - 0 + 1
	{
		int exchange = 0;//判断是否已经有序
		for (int j = 0; j < n - i - 1; j++)//每一趟，确定的最大值。n-i个数据则需要相邻比较n-i-1次。(n-i-2) - 0 + 1
		{
			if (a[j] > a[j+1])
			{
				swap04(&a[j], &a[j+1]);
				exchange = 1;
			}
		}
		if(exchange == 0)
			break;
	}
	/*
	for (int i = 0; i < n - 1; i++)//趟数，n个数，只需要冒泡n-1次。n-2 - 0 + 1
	{
		int exchange = 0;//判断是否已经有序
		for (int j = 1; j < n - i; j++)//每一趟，确定的最大值。n-i个数据则需要相邻比较n-i-1次。(n-i-1) - 1 + 1
		{
			if (a[j-1] > a[j])//尽量使用这种方式比较，if (a[j] > a[j+1])这种方法没有控制好边界，容易导致越界。可以通过具体值带入。
			{
				swap04(&a[j-1], &a[j]);
				exchange = 1;
			}//10个数，i=0时，
		}
		if (exchange == 0)
			break;
	}
	*/
}
void BubbleSort02(int* a, int n)//升序排列
{
	int end = n;
	while (end > 0)
	{
		int exchange = 0;
		for (int j = 1; j < end; j++)//每一趟，确定的最大值
		{
			if (a[j - 1] > a[j])//if (a[j] > a[j+1])这种方式容易越界
			{
				swap04(&a[j - 1], &a[j]);
				exchange = 1;
			}
		}
		if (exchange == 0)
			break;
		end--;
	}
}

//第一次比较N次
//第二次比较N-1次
//第三次比较N-2次
//...
//最坏的情况，时间复杂度：O(N) = N^2
//最好的情况，即有序：O(N) = N

//注意：冒泡排序, 比直接选择排序好，比直接插入排序差
//插入排序对于有序或接近有序的适应性更强。
//冒泡排序的特性总结：
//1. 冒泡排序是一种非常容易理解的排序
//2. 时间复杂度：O(N^2)
//3. 空间复杂度：O(1)
//4. 稳定性：稳定

//每次将最小的数冒泡到最顶端
void BubbleSort03(int* array, int n)//升序排列
{
	for (int i = 0; i < n - 1; i++) //冒泡轮数，n个数，只需要n-1个最大的数。
	{
		// [6], [2, 4, 5, 1, 3, -1] 经过第一个元素和后面所有的元素比较交换后，得
		// [-1], 6, 4, 5, 2, 3, 1

		// -1, [6], [4, 5, 2, 3, 1] 经过第二个元素和后面所有的元素比较交换后，得
		// -1, [1],  6, 5, 4, 3, 2

		// -1, 1, [6], [5, 4, 3, 2] 经过第三个元素和后面所有的元素比较交换后，得
		// -1, 1, [2],  6, 5, 4, 3

		// -1, 1, 2, [6], [5, 4, 3] 经过第四个元素和后面所有的元素比较交换后，得
		// -1, 1, 2, [3],  6, 5, 4

		// -1, 1, 2, 3, [6], [5, 4] 经过第五个元素和后面所有的元素比较交换后，得
		// -1, 1, 2, 3, [4],  6, 5

		// -1, 1, 2, 3, 4, [6], [5] 经过第六个元素和后面所有的元素比较交换后，得
		// -1, 1, 2, 3, 4, [5],  6
		for (int j = i + 1; j < n; j++) //每轮冒泡一个最小的数到最顶端。j是后面的数下标，最大不能超过n-1。
		{
			if (array[j] < array[i])//假设第i个下标是最小的，与后面的数依次比较，交换。 
			{
				int temp = array[j];
				array[j] = array[i];
				array[i] = temp;
			}
		}
	}
}
//本质上这是一个直接插入排序，详见直接插入排序。

void BubbleSort04(int* arr, int n)//升序排序 
{
	//[6] -1, 4, 5, 2, 3, 1
	// -1  6  4, 5, 2, 3, 1

	//[-1  6] 4, 5, 2, 3, 1
	// -1  4  6, 5, 2, 3, 1

	//[-1  4  6] 5, 2, 3, 1
	// -1  4  5  6, 2, 3, 1

	//[-1  4  5  6] 2, 3, 1
	// -1  2  4  5  6, 3, 1

	//[-1  2  4  5  6] 3, 1
	// -1  2  3  4  5  6, 1

	//[-1  2  3  4  5  6] 1
	// -1  1  2  3  4  5  6
	for (int i = 1; i < n; ++i)//n个数，需要n-1次。(n-1) - 1 + 1
	{
		for (int j = i; j >= 0; --j)//每次与前面的数相邻比较，冒泡出一个最小的到顶端。 
		{
			if (arr[j - 1] > arr[j])
			{
				arr[j - 1] = arr[j - 1] ^ arr[j];
				arr[j] = arr[j - 1] ^ arr[j];
				arr[j - 1] = arr[j - 1] ^ arr[j];
			}
			else break;
		}
	}
}

void BubbleSort05(int* array, int n)
{
	int temp = 0;
	//冒泡排序
	for (int i = n - 1; i >= 0; i--)
	{
		for (int j = 0; j < i; j++)
		{	//0 - n-1 范围内的数交换
			//0 - n-2 范围内的数交换
			//0 - n-3 范围内的数交换
			//...
			if (array[j] > array[j + 1])
			{
				temp = array[j];
				array[j] = array[j + 1];
				array[j + 1] = temp;
			}
		}
	}
}
#if 0
int main()
{
	//测试用例：
	//9, 3, 5, 2, 7, 8, 6,-1, 9, 4, 0
	//6 -1, 4, 5, 2, 3, 1    
	int a[] = { 87,78,16,94 };

	int n = sizeof(a) / sizeof(a[0]);

	BubbleSort04(a, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}
#endif

//多画图。

//冒泡排序的特性总结：
//1. 冒泡排序是一种非常容易理解的排序
//2. 时间复杂度：O(N ^ 2)
//3. 空间复杂度：O(1)
//4. 稳定性：稳定