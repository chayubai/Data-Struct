#define _CRT_SECURE_NO_WARNINGS 1
//插入排序的思路：
//直接插入排序是一种简单的插入排序法。
//其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，
//直到所有的记录插入完为止，得到一个新的有序序列。实际中我们玩扑克牌时，就用了插入排序的思想
//实际中我们玩扑克牌时，就用了插入排序的思想

//核心思想：摸上来的数，插入到已经有序的序列中的合适位置，使其继续有序。

//插入排序之希尔排序

//希尔排序（缩小增量排序）是在直接插入排序的基础上的优化
//1、先进行预排序，让数组接近有序
//2、进行直接插入排序

//希尔排序法又称缩小增量法。希尔排序法的基本思想是：先选定一个整数，把待排序文件中所有
//记录分成个组，所有距离为的记录分在同一组内，并对每一组内的记录进行排序。然后，取，重
//复上述分组和排序的工作。当到达 = 1时，所有记录在统一组内排好序。

//希尔排序思想：
//从分组中进行排序，在直接排序的思想上，每次比较后，
//如果不满足，将数据挪gap步，指针向前进gap步，
//如果满足，放在指针的下gap位置后面。使它接近有序，再使用直接插入排序。
//（从而是需要插入的数据挪动的很快，最后使得直接插入排序挪动数据效率增加了）

#include <stdio.h>
//预排序：即将数组进行分组排，间隔为gap是一组，进行分组，对多个分组进行直接插入排序，使得整个数组接近有序。
//例如：9 8 7 6 5 4 3 2 1 0
//假设gap == 3，注意gap为多少，就会被分成多少组。
//则：
//第一组：9 # # 6 # # 3 # # 0	排序后：0 # # 3 # # 6 # # 9
//第二组：8 # # 5 # # 2			排序后：2 # # 5 # # 8
//第三组：7 # # 4 # # 1			排序后：1 # # 4 # # 7
//即：
//i = 0  9和6对换   6 # # 9   6 8 7 9 5 4 3 2 1 0
//i = 1  8和5对换   5 # # 8   6 5 7 9 8 4 3 2 1 0
//i = 2  7和4对换   4 # # 7   6 5 4 9 8 7 3 2 1 0
//i = 3  6 9 3 0直接插入排序  3 5 4 6 8 7 9 2 1 0
//...
//i = 6 = n - gap - 1         0 2 1 3 5 4 6 8 7 9 
//0 2 1 3 5 4 6 8 7 9 直接插入排序：1 2 3 4 5 6 7 8 9

//对多组间隔为gap的数据预排序，gap由小变大。
//gap越大，大的数可以越快的到后面，小的数可以越快的到前面。
//gap越大，预排序越不接近有序
//gap越小，越接近有序
//gap==1时，就是直接插入排序。

/*
void ShellSort(int* a, int n)
{
	int gap = 3;//gap = 1即直接插入排序，但这样gap间隔固定写死了
	//把间隔为gap的多组数据同时排
	for (int i = 0; i < n - gap; i++)
	{
		int end = i;
		int tmp = a[end + gap];//end + gap < n, end < n - gap
		while (end >= 0)//内层循环控制某一组的某个数据进行直接插入排序
		{
			if (tmp < a[end])
			{
				a[end + gap] = a[end];
				end -= gap;//每次跳跃gap
			}
			else
			{
				break;
			}
		}
		a[end + gap] = tmp;
	}
}
*/
//注意：将直接插入排序中的1替换为gap就能实现希尔排序

void ShellSort(int* a, int n)
{
	int gap = n;
	while (gap > 1)
	{
		gap = gap / 2;//一定可以保证最后一次gap == 1或者gap = gap / 3 +1 也可以保证最后一次gap == 1
		//gap > 1时都是预排序，接近有序
		//gap == 1时就是直接插入排序，有序
		
		//把间隔为gap的多组数据同时排
		for (int i = 0; i < n - gap; i++)
		{
			int end = i;
			int tmp = a[end + gap];
			while (end >= 0)
			{
				if (tmp < a[end])
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}
//时间复杂度：
//假设gap = gap / 2方式，则外层while循环的次数是：
//n/2/2/2 .../2 = 1 =>n = log2 n 
//假设gap = gap / 3 + 1方式，则外层while循环的次数接近：
//n/3/3/3 .../3 = 1 =>n = log3 n
//当gap很大时，下面预排序时间复杂度O(N)
//当gap很小时，数组已经很接近有序了，这时预排序差不多也是O(N)
//总时间复杂度为：O(log2 n * N)或O(log3 n * N)
//平均时间复杂度为：O(N^1.3)

#if 0
int main()
{
	int a[] = { 5, 2, 4, 6, 1, 3 };
	int n = sizeof(a) / sizeof(a[0]);

	ShellSort(a, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}
#endif

//多画图。

//希尔排序的特性总结：
//1. 希尔排序是对直接插入排序的优化。
//2. 当gap > 1时都是预排序，目的是让数组更接近于有序。当gap == 1时，数组已经接近有序的了，
//这样就会很快。这样整体而言，可以达到优化的效果。我们实现后可以进行性能测试的对比。
//3. 希尔排序的时间复杂度不好计算，需要进行推导，推导出来平均时间复杂度： O(N ^ 1.3―N ^ 2）
//4. 稳定性：不稳定