#define _CRT_SECURE_NO_WARNINGS 1

//1、非比较排序之基数排序
//基数排序也叫桶排序，也就是依次分别取他们的个位，十位，百位...排序。
//如：123 45 12 9 88 43
//第一次按个位排序：12 123 43 45 88 9
//第二次按百位排序：9 12 123 43 45 88
//...
//注意：基数排序只能对整数排序，实际中意义不大，很少用，校招基本不考。

//2、非比较排序之基数排序
//如：4 4 6 8 9 3 3 0 0
//第一步：用一个数组记录每个数出现的次数，每个下标表示实际要排序的值 
//次数 2 0 0 2 2 1 1 0 1 1
//下标 0 1 2 3 4 5 6 7 8 9  (绝对映射位置)
//第二步：利用保存统计次数的数组进行排序，遍历开辟的数组，将数据放到原数组中(利用次数排序)
//0 0 3 3 4 5 6 8 9 

//注意：数组最大值有多大，就开辟多大的空间，由于前面可能没有数据，会造成空间浪费。(绝对映射位置)
//如何解决空间浪费问题？
//找出数组中最大的数和最小的数，开辟max-min+1个空间，然后开辟的数组下标为a[i]-min。(相对映射位置)
//如：100 101 102 101 108 105
//第一步：总是开辟108-100+1个int大小空间，统计每个数出现的次数
//次数     1   2   1   0   0   1    0   0   1  
//相对下标 0   1   2   3   4   5    6   7   8 
//绝对下标 100 101 102 103 104 105  106 107 108
//第二步：利用保存统计次数的数组进行排序，遍历开辟的数组，然后将实际数据(i+num)放到原数组中(利用次数排序)
//100 101 101 102 105 108

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void CountSort(int* a, int n)
{
	//1、求出最大的数和最小的数
	int max = a[0], min = a[0];
	for (int i = 0; i < n; i++)
	{
		if (a[i] > max)
		{
			max = a[i];
		}
		if (a[i] < min)
		{
			min = a[i];
		}
	}

	//计算映射空间的近似大小
	int range = max - min + 1;

	//开辟数组空间
	int* count = (int*)malloc(sizeof(int) * range);
	if (count == NULL)
		return;

	memset(count, 0, sizeof(int) * range);//初始化为0，因为最开始所有的数出现的次数都是0次
	
	//2、统计数出现的次数
	for (int i = 0; i < n; i++)
	{
		count[a[i]-min]++;//在a[i]-min相对位置的数据从0开始统计，即++
	}

	//3、利用次数排序。将count数组中的数，放入到原数组中
	int j = 0;
	for (int i = 0; i < range; i++)//控制哪个下标的数据
	{
		while (count[i]--)//控制每个数据的次数，循环放数据
		{
			a[j] = i + min;//下标+min = 最初的值。相当于a[j++] = i + min;
			j++;
		}
	}
	free(count);
}
//时间复杂度:F(N) = n + n + range 即：O(N) = n + range 或 O(N) = (MAX(n,range))
//说明该算法适用于范围集中的一组整型数据排序，使用范围具有局限性。
//范围较大，或者是浮点数都是不适合排序的。注意：相对映射可以排负数整数。绝对映射不可以，需要处理负数的问题。
//空间复杂度：O(N) = range

#if 0
int main()
{
	int a[] = { 6, 2, 4, 5, 1, 3, -1 };
	int n = sizeof(a) / sizeof(int);
	CountSort(a, sizeof(a) / sizeof(int));

	for (int i = 0; i < n; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}
#endif