#define _CRT_SECURE_NO_WARNINGS 1

//归并排序思路：
//归并排序（MERGE - SORT）是建立在归并操作上的一种有效的排序算法, 该算法是采用分治法 （Divideand Conquer）的一个非常典型的应用。
//将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

//什么是归并？
//将数组分成两个区间，各自进行排序后，再对两个区间归并成一个区间。
//需要注意归并的前提：左半区间和右半区间都有序，才能归并。
//归并思路：每次从两个区间中，取小的那个数放到新的临时数组中，最后拷贝新数组中的数到原数组中。（归并的过程中只要其中一个区间结束了，将另一个区间剩余的数据拷贝到临时数组中）
//对于左半区间,右半区间不是有序，怎么办？继续将其分成两个区间，直到分成不可再分的区间，再归并。

//归并排序(升序)
//第1步、分治算法思想
//通过分治思想：进行整体排序，使得最后分解成关键字左右都是一个数。将问题不断缩小到不可再分的子问题。
//以数组中间下标为分界，如果左半区间或右半区间不有序，则对不有序的区间分割成左半区间和右半区间。
//如果被分割的左半区间或右半区间继续不是有序，则同上面的方法，继续分割左半区间或右半区间......
//依次如此下去，直到区间被缩小到一个数时，最后开始归并。
//第2步、归并思想
//只需要开辟一个n个数组个数的空间，按照原数组和新数组下标对应关系归并两个区间。然后，再按下标对应关系，将新数组中的数拷贝到原数组中。

//注意：降序排序就是，归并的时候，每次取大的那个数放到新数组中。
#include <stdio.h>
#include <stdlib.h>

void _MergeSort(int* a, int left, int right, int* tmp)
{
	//如果只有一个值，或者交叉，结束
	if (left >= right)
	{
		return;
	}
	int mid = (left + right) >> 1;//中间位置的下标
	//假设【left,mid】【mid,right】不有序，则递归左半区间和右半区间使其有升序，那么就可以归并了。
	//其实，不管有不有序都会分割区间
	_MergeSort(a, left, mid, tmp);
	_MergeSort(a, mid+1, right, tmp);

	//归并 - 两个有序区间合并为一个区间
	int begin1 = left, end1 = mid;//左半区间两端的下标
	int begin2 = mid + 1, end2 = right;//右半区间两端的下标
	int index = left;//映射到临时数组的某个归并后的区间的最左下标。不能赋值0，因为归并后的下标不一定是最左边0下标处。
	while (begin1 <= end1 && begin2 <= end2)//两个都没有结束，则继续。有一个结束，则结束。
	{
		if (a[begin1] < a[begin2])//如果降序，则if (a[begin1] > a[begin2])
		{
			tmp[index++] = a[begin1++];
		}
		else
		{
			tmp[index++] = a[begin2++];
		}
	}
	//如果前半区间有剩余
	while (begin1 <= end1)
	{
		tmp[index++] = a[begin1++];
	}
	//如果后半区间有剩余
	while (begin2 <= end2)
	{
		tmp[index++] = a[begin2++];
	}

	//将新数组中的数拷贝到原数组中。即将映射的新数组某区间中的数，按映射关系，拷贝回原数组中去。
	for (int i = left; i <= right; i++)
	{
		a[i] = tmp[i];
	}
}
void MergeSort(int* a, int n)
{
	int* tmp = (int*)malloc(sizeof(int) * n);
	_MergeSort(a, 0, n - 1, tmp);
	free(tmp);
}
#if 0
int main()
{
	int a[] = { 6, 2, 4, 5, 1, 3, -1 };
	int n = sizeof(a) / sizeof(int);
	MergeSort(a, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}
#endif

//多注意边界值的控制。归并排序核心思想：类似于后序遍历。多调试理解逻辑。

//归并排序的特性总结：
//1. 归并的缺点在于需要O(N)的空间复杂度，归并排序的思考更多的是解决在磁盘中的外排序问题。
//2. 时间复杂度：O(N * logN)
//3. 空间复杂度：O(N)
//4. 稳定性：稳定