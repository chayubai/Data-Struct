#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <stdlib.h>

//插入排序的思路：
//直接插入排序是一种简单的插入排序法。
//其基本思想是：把待排序的记录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，
//直到所有的记录插入完为止，得到一个新的有序序列。实际中我们玩扑克牌时，就用了插入排序的思想
//实际中我们玩扑克牌时，就用了插入排序的思想

//核心思想：摸上来的数，插入到已经有序的序列中的合适位置，使其继续有序。

//插入排序之直接插入排序

//直接插入排序思想：
//如何找到有序序列的合适位置呢？
//单趟排序时：（即对于已经有序的数组，插入一个数，使它继续有序），
//最初下标指向有序数组的最后一个数，从后往前开始，与需要插入的数据进行比较。
//假设升序排列：
//如果不满足，即插入的数据小于数组下标位置的数据时，将下标所在的数往后挪一个位置，再下标前进一位，继续比较。
//如果满足，即插入的数据大于等于数组下标位置的数据时，放在该下标的后一个位置上。
//整体排序时：先假设第一个数有序，从第二个数开始按单趟排序思路，依次对后面所有要插入的数进行排序。

//假设为升序排序
void InsertSort(int* a,int n)
{
	//整体排序：第一个有序区间为【0,0】，n个数需要有n-1个有序区间，n-1次插入，需要排n-1趟，即控制单趟排序的次数
	for (int i = 0; i < n - 1; i++)//n - 2 - 0 + 1次,这里是n-1
	{
		//单趟排序：从end处从后往前找，如果end处的数据比要插入的end+1处的数据大，则往后挪。
		//【0，end】区间有序，让end+1位置的值插入进去，让【0，end+1】有序
		int end = i;//注意，有序数组的下标。end不能等于n-1，否则end+1会越界
		int tmp = a[end + 1];//保存end后面的数，防止数据挪动把后一个数覆盖了，无法知道需要插入的数
		//2 4 5 6 | 1 3
		//1 2 4 5 6 | 3
		//有序区间每个元素从后往前与比要插入的元素比较
		while (end >= 0)//不能是这个条件tmp < a[end]，因为可能a[-1]也大于tmp，造成越界访问比较。只能通过下标控制挪动的循环次数
		{
			if (a[end] > tmp)
			{
				a[end + 1] = a[end];
				end--;//此处end--，最后tmp要将数据放到end+1处
			}
			else//找到了合适位置
			{
                //第一种情况：1 2 4 5 6 | 3
				//tmp >= a[end]，这里需要放入数据到end后一个位置,即a[end + 1] = tmp;
                //第二种情况：2 3 4 5 6 | 1 
                //tmp比所有的数(循环遍历一遍结束)都要小，此时下标end为-1，退出循环。
                //再在循环外放入数据到end后一个位置，即a[end + 1] = tmp;也是a[0] = tmp; 
				
				break;//使用break，并都会放入数据，a[end + 1] = tmp;放在循环后面，可以合并这两种情况
			}
		}
        a[end + 1] = tmp;
        
        /*
        //等价写法
        while ((end >= 0) && (a[end] > tmp))
		{
			a[end + 1] = a[end];
			end--;
		}
        a[end + 1] = tmp;
        */	
	}
}
//时间复杂度：
//最坏的情况 - 对一个已经有序的数组逆序时，a[end + 1] = tmp;经历的次数 F(N) = 1+2+3+4 ... + (n-)1 = O(N^2)
//最好的情况 - 对一个已经有序的数组顺序时，a[end + 1] = tmp;经历的次数 F(N) = 1+1+1+1 ... = N-1 = O(N)
#if 0
int main()
{
	int a[] = { 5, 2, 4, 6, 1, 3 };
	int n = sizeof(a) / sizeof(a[0]);

	InsertSort(a, n);

	for (int i = 0; i < n; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}
#endif

//其他方法：
//方法1
void swap01(int* a, int* b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
void InsertSort01(int arr[], int sz)
{
    //3 | 2  1  0  8  5

    //2  3 | 1  0  8  5

    //0  1  2  3 | 8  5
    int i = 0;
    for (i = 0; i < sz - 1; i++)
    {
        int j = 0;
        int end = i;
        //先[0,end]中每个元素,与arr[end+1]每比较一次，就进行交换
        for (j = 0; j <= end; j++)
        {
            if (arr[end + 1] < arr[j])
            {
                swap01(&arr[end + 1], &arr[j]);
            }
        }
    }
}

//方法2
void InsertSort02(int arr[], int sz)
{
    //2  3 | 1  0  8  5

    //0  1  2  3  8 | 5
    int i = 0;
    for (i = 0; i < sz - 1; i++)
    {
        int j = 0;
        int end = i;
        //先[0,end]中找符合的位置j，将[j,end]往后挪，将end+1处的数据放到j位置处
        int num = arr[end + 1];
        for (j = 0; j <= end; j++)
        {
            if (arr[end + 1] < arr[j])
            {
                while (end >= j)
                {
                    arr[end + 1] = arr[end];
                    end--;
                }
                arr[j] = num;
                break;
            }
        }
    }
}

//方法3
void InsertSort03(int* array, int n)//插入排序
{
    //   tmp
    //6, 2, 6, 4, 5, 1, 3, -1
    //2, 6, 6, 4, 5, 1, 3, -1

    //      tmp
    //6, 2, 6, 4, 5, 1, 3, -1
    //2, 6, 6, 4, 5, 1, 3, -1


    //         tmp
    //6, 2, 6, 4, 5, 1, 3, -1
    //2, 4, 6, 6, 5, 1, 3, -1
    int i, j, temp;
    for (i = 1; i < n; i++)
    {
        if (array[i] < array[i - 1])//如果end+1位置的数比前一个数小，则需要插入
        {
            temp = array[i];
            //挪动位置
            for (j = i - 1; j >= 0 && temp < array[j]; j--)
            {
                array[j + 1] = array[j];
            }
            array[j + 1] = temp;

            /*
            //等价写法
            for (j = i - 1; j >= 0; j--)
            {
                if(temp < array[j])
                    array[j + 1] = array[j];
                else
                    break;//没有else 否则，会继续循环，判断，然后将前面小的数，也挪动了位置
            }
            array[j + 1] = temp;
            */
        }
    }
}

//多画图。

//直接插入排序的特性总结：
//1. 元素集合越接近有序，直接插入排序算法的时间效率越高
//2. 时间复杂度：O(N ^ 2)
//3. 空间复杂度：O(1)，它是一种稳定的排序算法
//4. 稳定性：稳定